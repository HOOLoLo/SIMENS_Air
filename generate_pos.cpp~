//
// Created by zgd on 18-4-20.
//

#include"serial_usb_com.h"

#include "generate_pos.h"
#include <iostream>
#include "analy_route.h"
#include "analy.h"
#include "Serial_RT.h"
#include "send_commend.h"
#include <list>
#include <cstring>
#include "run_light.h"
using namespace std;

int time_tag=0;

void command_thread(){//è¿äžªåœæ°æ¯æŽäžªçšåºçæ žå¿,å®æäºïŒæ¥åuwbæ°æ®ïŒçæäœçœ®ïŒå€æ­äœçœ®ïŒè®Ÿçœ®åç»ïŒåéåœä»€ææä»»å¡
    char *com = "/dev/ttyUSB0" ;//è¯»åuwbè®Ÿå€äž²å£å
    char *uart1="/dev/ttyAMA1";//åæ äººæºåéåœä»€äž²å£
    int uart1_para=9600;

    int len;//bufæ°ç»å€§å°
    int out=0 ;//çšäºå€æ­outputæ°ç»æ¯åŠå®æäº
    int ibx ;//uwbæ°æ®äž­åºç«çè·çŠ»
    int icy ;//uwbæ°æ®äž­ä¿¡å·çåŒºåºŠ
    int ret ;//çšäºuwbæ°æ®åç±»ïŒF1æ¯ä¿¡æ æ°æ®ïŒ1æ¯ç¬¬äžäžªåºç«æ°æ®ïŒ0æ¯ç¬¬2,3,4....åºç«çæ°æ®ïŒåŠææ¯-1å°±æ¯æ²¡æè§£æåºæèæ²¡æ¶å°æ°æ®
    short x=0,y=0,z=0 ;//äžŽæ¶è®°åœå®äœç®æ³ç»åºçx,y,z
    char rcv_buf[200] ;
    char mac[80] ;
    int check_num=0;//记录定位数据次数(加在一开始)


    while(open_serial(com)==-1){//æåŒuwbäž²å£
        sleep(10) ;
    }
    while (uart_open(command_serial_fd,uart1,uart1_para)==-1){
        sleep(1);
    }
//    while(uart_set(command_serial_fd,uart1_para,0,8,'N',1) == -1){
//        sleep(1);
//    }

    int t=1;
    while(/*çå¬tcpæ¥åè·¯çº¿ä»»å¡*/t) {
       //if(æ¶å°èµ·ç¹,ç»ç¹ start,dst){
            int start=0;
            int dst=1;
       // }
        if(generate_route(start,dst)&&!route.empty()) {
            cout<<"generate route success"<<endl;
	cout<<"route_size="<<route.size()<<endl;
            list<int>::iterator it = route.begin();//iteratoræåè·¯åŸç¬¬äžäžªåçŽ 
            take_off();

       sleep(2);         


	//    sleep(60);

	//send_land();
//            uart_write(command_serial_fd,switch_hover,5);
            cout<<"take off success"<<endl;


            //åéèµ·é£åœä»€,æ¬ååœä»€,è¿èŠè§£ææ äººæºç»çé«åºŠæ°æ®.

            int str, nstr;//çšäºç¡®å®ç¬¬äžäžªç¯ç®¡çé¢è²
            str=*it;
            nstr=*(++it);
            pthread_mutex_lock(&mutex_colortag);
            colortag=G[str][nstr].color;
            pthread_mutex_unlock(&mutex_colortag);
            it--;//æitååæ¥


            pthread_mutex_lock(&mutex_light_thread);
            light_thread=true;
            pthread_mutex_unlock(&mutex_light_thread);

            pthread_create(&run_light_id,NULL,run_light,NULL);//èµ·é£ç»æåå¯åšåŸåè°æŽçº¿çš
       	    
	    sleep(10);
	    
	    pthread_create(&adjust_thread_id,NULL,adjustment,NULL);//调整线程
	    sleep(25);
	    time_tag=1;	
//	 send_go_forward();
//	send_go_back();
//	sleep(60);
//	send_land();			
            while (it != (--route.end())) {//åªèŠåœåitäžæ¯æåäžäžªèç¹å°±åŸªç¯
                int current_node, next_node;//åœåèç¹çŒå·åäžäžäžªèç¹çŒå·
                current_node = *it;
                next_node = *(++it);
		cout<<"current_node="<<current_node<<endl;
		cout<<"next_node="<<next_node<<endl;
		cout<<"group="<<G[current_node][next_node].group<<endl;
                serial_set_group(G[current_node][next_node].group);

                pthread_mutex_lock(&mutex_colortag);
                colortag=G[current_node][next_node].color;
                pthread_mutex_unlock(&mutex_colortag);

                bool next_path = false;//
                while (!next_path) {
                    len = 100;
                    usleep(10);
                    memset(rcv_buf, '\0', len);
                    while(serial_read(rcv_buf, &len)==-1){
                        cout<<"read failed"<<endl;
                        usleep(1);
                    };//è¯»åuwbæ°æ®,åŠæå€±èŽ¥å°±åè¯»
//		    cout<<rcv_buf<<endl;
                    rcv_buf[len] = '\0';
                   // cout<<rcv_buf<<endl;
                    if (len > 0 && len < 80) {

                        memset(mac, '\0', 50);

                        ret = get_info(rcv_buf, len, mac, &ibx, &icy);
                        if (ret == -1) {
                            cout<<"read info failed"<<endl;
                            continue;//åŠæåææ°æ®å€±èŽ¥ç»ææ¬æ¬¡åŸªç¯ïŒè¿è¡äžäžæ¬¡åŸªç¯ïŒåæ¬¡è¯»åæ°æ®
                        }
                        bool set_pos_success=false;//è®°åœoutputæ°ç»æ°æ®æ¯åŠè®Ÿçœ®å®æ
                        //äºç»Žè®¡ç®æ¹æ³
                        if (G[current_node][next_node].dimension == 2) {
                            out = 0;//çšäºè®°åœæ¯åŠæ°æ®è®Ÿçœ®æåïŒ
                            set_info(ret, mac, (float) ((ibx + 1) / 100.0), &out);//äºç»Žçæ¹åŒè·åå°åæ å¹¶èµåŒïŒè¿éå§ibxåç±³åäœæ¢æç±³
                            if (out == 0xff)//è®Ÿçœ®èŸåºå®æ
                            {
                                x = (short) (output[0] * 100);
                                y = (short) (output[1] * 100);
                                z = (short) (output[2] / 20);
                                set_pos_success=true;
                            }
                            else set_pos_success=false;

                        }
                            //äžç»Žè®¡ç®æ¹æ³
                        else if (G[current_node][next_node].dimension == 1) {
                            out = 0;
                            set_one_dimension(ret, mac, (float) ((ibx + 1) / 100.0), &out);
                            if (out == 0xff) {
                                x = (short) (output[0] * 100);
                                y = (short) (output[1] * 100);
                                z = (short) (output[2] / 20);
                                set_pos_success=true;
                            }
                            else set_pos_success= false;
                        }
			//cout<<"pix_x="<<pix_x<<"pix_y="<<pix_y<<endl;
                        if(set_pos_success==true) {//åŠæuwbæ°æ®å®äœå®æïŒå¯çšç¯ç®¡å®äœ
                         

			cout<<"color ="<<G[current_node][next_node].color<<endl;
			cout<<"pix_x="<<pix_x<<"pix_y="<<pix_y<<endl;
   //åå¯¹åçŽ åæ è¿è¡å€æ­äžäžææ²¡æåºé
                            if((pix_x>=10&&pix_x<=630)||(pix_y>=10&&pix_y<=470)) {
                                //å€æ­ç¯ç®¡ä¿®æ¹åæ å
                                pthread_mutex_lock(&mutex_pix);
                                if (G[current_node][next_node].color == 1) {//èè²ç¯ç®¡æ¹åyæ¹åçåŒ
                                    y = G[current_node][next_node].light_pos + ((pix_x - 320) * 10) / 15;
					cout<<"blue color success"<<endl;
                                } else if (G[current_node][next_node].color == 2) {//çº¢è²ç¯ç®¡æ¹åxæ¹åçåŒ
                                    x = G[current_node][next_node].light_pos + ((pix_y - 240) * 10) / 15;
				    cout<<"red_light_set_success"<<endl;
					cout<<"light_pos="<<G[current_node][next_node].light_pos<<endl;
					
                                } else cout << "color set error" << endl;//è¿éåé¢å¯ä»¥åå°æ¥å¿é
                                pthread_mutex_unlock(&mutex_pix);
                            }
                            //å€æ­æ¯åŠåšèåŽååŠæåšèåŽåå°±ç»åšå±çX,Y
                            if ((x >= 0) && (y >= 0) && (x < maxX) && (y < maxY)) {
                                X = x;
                                Y = y;
                                printf("X=%d,Y=%d\r\n",X,Y);
//                                cout << "X=" << X << endl;
//                                cout<< "Y=" << Y << endl;
                                //ç¶åå€æ­åœååæ 
                                //è¿édst_x,hådst_yäž­å¶äž­äžäžªè¯å®æ¯åç¯ç®¡åæ äžæ ·ç,äœæ¯åœä»€æ§å¶åŸ®è°åæ®éçè°äžäžæ ·çè¯
                                int isArrive;
                                isArrive=generate_command( G[current_node][next_node].dst_x,G[current_node][next_node].dst_y, G[current_node][next_node].str_x, G[current_node][next_node].str_y,X,Y);
                                if(isArrive==1) {

                                    check_num++;//检测到一次到达点就check_num+1;

                                }
			        else{
                                    check_num=0;
			            cout<<"current="<<current_node<<endl;
			            cout<<"next="<<next_node<<endl;
					            }
                             if(check_num>=3){
                                    next_path=true;
                                    send_hover();//坐标判断到达中心点,悬停
				    	
				    //pthread_mutex_lock(&mutex_colortag);
                		    //colortag=3;
                		    //pthread_mutex_unlock(&mutex_colortag);
				/*while(1){

				cout<<" changing "<<endl;
				if(abs(pix_x-360)<10&&abs(pix_y-240)<10){
					   pthread_mutex_lock(&mutex_colortag);
               				   colortag=0;
                			 pthread_mutex_unlock(&mutex_colortag);
	     						break;								
					}
				}*/
                                    sleep(30);
				//图像微调
                                    check_num=0;
                            }

                               /* if (G[current_node][next_node].dst_x == G[current_node][next_node].light_pos) {
                                    if (abs(X - G[current_node][next_node].dst_x) > 10) {
                                        //xæ¹åäžåŸ®è°åœä»€
                                    }
                                    if (abs(Y - G[current_node][next_node].dst_y) > 10) {
                                        //yæ¹åäžç§»åšåœä»€
                                    }
                                } else {
                                    if (abs(X - G[current_node][next_node].dst_x) > 10) {
                                        //xæ¹åäžç§»åšåœä»€
                                    }
                                    if (abs(Y - G[current_node][next_node].dst_y) > 10 {
                                        // yæ¹åäžåŸ®è°åœä»€
                                    }
                                }*/

                            }
                        }
                    }
                }
            }

            //è·¯çº¿ä»»å¡å®æ
            //äžé

                send_land();
		cout<<"land success"<<endl;
                pthread_mutex_lock(&mutex_light_thread);
                light_thread=false;
                pthread_mutex_unlock(&mutex_light_thread);
                sleep(1);
            }
        }
         sleep(1);
    return ;
    }












void *adjustment(void* arg){
	int tm;
	int tm_sleep;
	int ad_pix_x,ad_pix_y;
	int color;
	
	while(light_thread){
	if(time_tag==0){
	tm=12;
	tm_sleep=500;
	}
	else if(time_tag==1){
	tm=3;
	tm_sleep=500;
	}
	else{
	tm=2;
	cout<<"time_tag error"<<endl;
	}
	pthread_mutex_lock(&mutex_pix);
	ad_pix_x=pix_x;
	ad_pix_y=pix_y;
	pix_x=0;
	pix_y=0;
	pthread_mutex_unlock(&mutex_pix);
	cout<<"pix_x="<<ad_pix_x<<"pix_y"<<ad_pix_y<<endl;
	if(ad_pix_x==0&&ad_pix_y==0){
		
		usleep(1000*300);
		continue;
	}
	 pthread_mutex_lock(&mutex_colortag);
         color=colortag;       
	pthread_mutex_unlock(&mutex_colortag);
	if(color==1)//蓝色
	{
		if(ad_pix_x>340&&ad_pix_x<640){
		send_go_left();
                cout<<"go_left"<<endl;
		
		while(tm--){
		usleep(1000*100);
		pthread_mutex_lock(&mutex_pix);
	        ad_pix_x=pix_x;
		ad_pix_y=pix_y;
		pix_x=0;
		pix_y=0;
		pthread_mutex_unlock(&mutex_pix);
		if(ad_pix_x>300&&ad_pix_x<340)break;		
		}
		//send_go_right();
		//usleep(1000*25);
		send_stop_cross();
		usleep(1000*tm_sleep);
		cout<<"and stop"<<endl;
											
		}
		else if(ad_pix_x>0&&ad_pix_x<300){
		send_go_right();
		cout<<"go_right"<<endl;
		while(tm--){
		usleep(1000*100);
		pthread_mutex_lock(&mutex_pix);
	        ad_pix_x=pix_x;
		ad_pix_y=pix_y;
		pix_x=0;
		pix_y=0;
		pthread_mutex_unlock(&mutex_pix);
		if(ad_pix_x>300&&ad_pix_x<340)break;		
		}
		//send_go_left();
		//usleep(1000*25);
		send_stop_cross();
		usleep(1000*tm_sleep);
		cout<<"and stop"<<endl;
		}
		// usleep(1000*50);
		else {
		send_stop_cross();
		cout<<"stop"<<endl;
		usleep(1000*100);	
		}
	}	
	if(color==2)//紅色
	{
	if(ad_pix_y>250&&ad_pix_y<480){
		send_go_back();
                cout<<"go_back"<<endl;
		usleep(1000*300);
		send_stop_front();								
	}

	else if(ad_pix_y>0&&ad_pix_y<230){
		send_go_forward();
		cout<<"go_front"<<endl;
		usleep(1000*300);
		send_stop_front();
	}
	else {
	send_stop_front();
	cout<<"stop"<<endl;	
	}		
        }
}
}











//    //int avg_one[5] ;
//   // int avg_one_index = 0 ;
//   // int avg_one_num = 0 ;
//    usleep(1000*10) ;
//  //  current_point = 0 ;
//    //serial_set_group(0x01) ;
//    //åŠæåœåç¹åç»ä¿¡æ¯äžäžºé¶ïŒåå§åç¯ç®¡é¢è²åç»æ ç­Ÿåå§åçåç»
//    while(G[][]){
//        serial_set_group(point_short[current_point][2]) ;//ç»æ ç­Ÿåéè®Ÿçœ®åç»åœä»€
//        //char sed[2]={3,0} ;
//        if(point_short[current_point][4]==1){
//            colortag=1;//blue
//            //sed[0]=0x01 ;//blue
//        }else if(point_short[current_point][4]==2){
//            colortag=2;//red
//            //sed[0]=0x02 ;//red
//        }
//        //udp_server_send(sed,1) ;
//        usleep(10) ;
//        break ;
//    }
//    //   char cmp[20]="32552428" ;
//    int pix_mid_x = 992 ;
//    int pix_mid_y = 2349 ;
//
//    while (1) { //åŸªç¯è¯»åæ°æ®
//
//        len = 100 ;
//        usleep(10) ;
//        memset(rcv_buf,'\0',len) ;
//        serial_read(rcv_buf,&len) ;
//        rcv_buf[len] = '\0';
////	  printf("%s",rcv_buf) ;
//        if(len > 0&&len<80){
//            memset(mac,'\0',50) ;
//            ret = get_info(rcv_buf,len,mac,&ibx,&icy) ;
////		printf("%s,%d\n",mac,ibx) ;
//            if(ret == -1){
//                continue ;
//            }
////		MY_LOG("%s,%d\n",mac,ibx) ;
//            //ååœåç¹çéçœ®ä¿¡æ¯ïŒç¡®å®ç®æ³ïŒäžç»Žãäºç»Ž
//            dimension_i = point_short[current_point][3] ;
//
//            if(dimension_i ==2){
//                //äºç»Ž
//                out = 0 ;//çšäºè®°åœæ¯åŠæ°æ®è®Ÿçœ®æåïŒ
//                set_info(ret,mac,(float)((ibx+1)/100.0),&out) ;//äºç»Žçæ¹åŒè·åå°åæ å¹¶èµåŒïŒè¿éå§ibxåç±³åäœæ¢æç±³
//                if(out==0xff)
//                {
//                    x=(short)(output[0]*100) ;
//                    y=(short)(output[1]*100) ;
//                    z=(short)(output[2]/20) ;
//                    //printf("%d,%d,%d\n",x,y,z) ;
//                    pthread_mutex_lock(&mutex_log) ;
//                    if(pix_x!=0){
//                        //	y = pix_mid_y+((pix_x-320)*10)/15 ;
//                        y = point_short[current_point][5]+((pix_x-320)*10)/15 ;
//                        //pix_x = 0 ;
//                    }
//                    if(pix_y!=0){
//                        //	x = pix_mid_x+((pix_y-240)*10)/15 ;
//                        x = point_short[current_point][5]+((pix_y-240)*10)/15 ;
//                        //pix_y = 0 ;
//                    }
//                    pthread_mutex_unlock(&mutex_log) ;
//                    memset(sed_buf,'\0',100) ;
//                    //printf("%d,%d,%d\n",x,y,z) ;
//                    if((x>=0)&&(y>=0)&&(x<maxX)&&(y<maxY))
//                    {
//                        set_posxyz(x,y,z,sed_buf,&len) ;
//                        if(len>100)
//                            continue ;
//                        memcpy(send_buf,sed_buf,len) ;
//                        send_len = len ;
//                        send_flag = 3 ;
//                        printf("x:%d,y:%d,z:%d---------------\n",x,y,z) ;
//                        //pthread_mutex_unlock(&mutex_log) ;
//                        avg_one_index++ ;
//                        if(avg_one_index%10==0){
//                            if(sock_fd_flag!=0){
//                                tcp_xyz(x,y,z,p_buf,&p_len) ;
//                                tcp_send(p_buf,p_len) ;
//                            }
//                        }
//                        //if(process_start == 1)
//                        {
//                            judge_position_i = judge_position(x,y,direction_i,current_point,10) ;
//                            judge_next_point(com,para) ;
//                        }
//                    }else{
//                        usleep(1) ;
//                    }
//                }
//            }else if(dimension_i == 1){
//                out = 0 ;
//                //set_one_info(ret,mac,ibx,&out,55) ;
////			printf("%s %d\n",mac,ibx) ;
//                set_one_dimension(ret,mac,(float)((ibx+1)/100.0),&out) ;
//                if(out==0xff){
//                    x=(short)(output[0]*100) ;
//                    y=(short)(output[1]*100) ;
//                    z=(short)(output[2]/20) ;
//                    //printf("xyz,%d,%d,%d\n",x,y,z) ;
//                    pthread_mutex_lock(&mutex_log) ;
//                    if(pix_x!=0){
//                        //	y = pix_mid_y+((pix_x-320)*10)/15 ;
//                        y = point_short[current_point][5]+((pix_x-320)*10)/15 ;
//                        //pix_x = 0 ;
//                    }
//                    if(pix_y!=0){
//                        //	x = pix_mid_x+((pix_y-240)*10)/15 ;
//                        x = point_short[current_point][5]+((pix_y-240)*10)/15 ;
//                        //pix_y = 0 ;
//                    }
//                    pthread_mutex_unlock(&mutex_log) ;
//                    memset(sed_buf,'\0',100) ;
//                    if((x>=0)&&(y>=0)&&(x<maxX)&&(y<maxY))
//                    {
//                        set_posxyz(x,y,z,sed_buf,&len) ;
//                        memcpy(send_buf,sed_buf,len) ;
//                        send_len = len ;
//                        send_flag = 3 ;
//
//                        avg_one_index++ ;
//                        if(avg_one_index%10==0){
//                            if(sock_fd_flag!=0){
//                                tcp_xyz(x,y,z,p_buf,&p_len) ;
//                                ret = tcp_send(p_buf,p_len) ;
//                            }
//                        }
//                        printf("x:%d,y:%d,z:%d\n",x,y,z) ;
//                        //if(process_start == 1)
//                        {
//                            judge_position_i = judge_position(x,y,direction_i,current_point,20) ;
//                            judge_next_point(com,para) ;
//                        }
//                    }
//                }
//            }
//
//        }else{
//            usleep(1) ;
//        }
//        usleep(1);
//    }
//    return NULL ;
//}
